/*
 * Java Genetic Algorithm Library (@!identifier!@).
 * Copyright (c) @!year!@ Franz Wilhelmstötter
 *  
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Author:
 *     Franz Wilhelmstötter (franz.wilhelmstoetter@gmx.at)
 *     
 */
package org.jenetics.examples;

import static java.awt.RenderingHints.KEY_ANTIALIASING;
import static java.awt.RenderingHints.VALUE_ANTIALIAS_ON;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.util.EventListener;
import java.util.EventObject;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import org.jenetics.DoubleChromosome;
import org.jenetics.DoubleGene;
import org.jenetics.FitnessFunction;
import org.jenetics.GeneticAlgorithm;
import org.jenetics.Genotype;
import org.jenetics.MeanAlterer;
import org.jenetics.Mutation;
import org.jenetics.RouletteWheelSelector;
import org.jenetics.util.Converter;
import org.jenetics.util.Factory;
import org.jenetics.util.Probability;
import org.jscience.mathematics.number.Float64;



/**
 * @author <a href="mailto:franz.wilhelmstoetter@gmx.at">Franz Wilhelmstötter</a>
 * @version $Id: Geometry.java,v 1.1 2009-03-09 18:48:21 fwilhelm Exp $
 */
public class Geometry extends javax.swing.JFrame {
	private static final long serialVersionUID = 1L;



	public Geometry() {
		initComponents();
	}	
	
	void setStartAction(final Action action) {
		startButton.setAction(action);
	}
	
	void setStopAction(final Action action) {
		stopButton.setAction(action);
	}
	
	void setInitAction(final Action action) {
		initButton.setAction(action);
	}
	
	void setPauseAction(final Action action) {
		pauseButton.setAction(action);
	}
	
	void setStepAction(final Action action) {
		stepButton.setAction(action);
	}
	
	void setSourcePolygon(final Point2D[] polygon) {
		((DrawPanel)drawPanel).setSourcePolygon(polygon);
	}
	
	void setTargetPolygon(final Point2D[] polygon) {
		((DrawPanel)drawPanel).setTargetPolygon(polygon);
	}
	
	void setPopulationBestTransform(final AffineTransform transform) {
		((DrawPanel)drawPanel).setPopulationBestTransform(transform);
	}
	
	void setAlltimeBestTransform(final AffineTransform transform) {
		((DrawPanel)drawPanel).setAlltimeBestTransform(transform);
	}
	
	public void repaint() {
		super.repaint();
		drawPanel.repaint();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        drawPanel = new DrawPanel();
        startButton = new javax.swing.JButton();
        stopButton = new javax.swing.JButton();
        initButton = new javax.swing.JButton();
        pauseButton = new javax.swing.JButton();
        stepButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        drawPanel.setBackground(java.awt.Color.white);
        drawPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        javax.swing.GroupLayout drawPanelLayout = new javax.swing.GroupLayout(drawPanel);
        drawPanel.setLayout(drawPanelLayout);
        drawPanelLayout.setHorizontalGroup(
            drawPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 530, Short.MAX_VALUE)
        );
        drawPanelLayout.setVerticalGroup(
            drawPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 468, Short.MAX_VALUE)
        );

        startButton.setText("Start");

        stopButton.setText("Stop");

        initButton.setText("Init");

        pauseButton.setText("Pause");

        stepButton.setText("Step");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(drawPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(stopButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pauseButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(stepButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(startButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(initButton, javax.swing.GroupLayout.DEFAULT_SIZE, 74, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(drawPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(initButton)
                        .addGap(32, 32, 32)
                        .addComponent(startButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(stepButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(pauseButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(stopButton)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

	
	/**
	 * @param args
	 *            the command line arguments
	 */
	public static void main(String args[]) {
		java.awt.EventQueue.invokeLater(new Runnable() {
			public void run() {
				final Geometry geometry = new Geometry();
				geometry.setVisible(true);
				new GeometryController(geometry);
			}
		});
	}

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel drawPanel;
    private javax.swing.JButton initButton;
    private javax.swing.JButton pauseButton;
    private javax.swing.JButton startButton;
    private javax.swing.JButton stepButton;
    private javax.swing.JButton stopButton;
    // End of variables declaration//GEN-END:variables

}

class GeometryController implements StepListener {
	private final Geometry _geometry;
	
	private final InitAction _initAction = new InitAction(this);
	private final StartAction _startAction = new StartAction(this);
	private final StopAction _stopAction = new StopAction(this);
	private final StepAction _stepAction = new StepAction(this);
	private final PauseAction _pauseAction = new PauseAction(this);
	
	private GeneticAlgorithm<DoubleGene, Float64> _ga;
	private GA.Function _function;
	private Point2D[] _source;
	private Point2D[] _target;
	private Stepable _stepable;
	private Thread _thread;
	
	public GeometryController(final Geometry geometry) {
		_geometry = geometry;
		
		_geometry.setInitAction(_initAction);
		_geometry.setStartAction(_startAction);
		_geometry.setStopAction(_stopAction);
		_geometry.setStepAction(_stepAction);
		_geometry.setPauseAction(_pauseAction);
		
		init();
	}
	
	void init() {
		_source = GA.getSourcePolygon();
		_target = GA.getTargetPolygon();
		_function = new GA.Function(_source, _target);
		
		_ga = new GeneticAlgorithm<DoubleGene, Float64>(
				GA.getGenotypeFactory(), _function
			);
		_ga.addAlterer(new Mutation<DoubleGene>(Probability.valueOf(0.03)));
		_ga.addAlterer(new MeanAlterer<DoubleGene>(Probability.valueOf(0.3)));
		_ga.setSelectors(new RouletteWheelSelector<DoubleGene, Float64>());
		_ga.setPopulationSize(20);
		_ga.setMaximalPhenotypeAge(35);
		
		_geometry.setSourcePolygon(_source);
		_geometry.setTargetPolygon(_target);
		
		if (_stepable != null) {
			_stepable.removeStepListener(this);
		}
		_stepable = new Stepable(new Runnable() {
			@Override public void run() {
				if (_ga.getGeneration() == 0) {
					_ga.setup();
				} else {
					_ga.evolve();
				}
				_stepAction.setEnabled(true);
			}
		});
		_stepable.addStepListener(this);
		
		_thread = new Thread(_stepable);
		_thread.start();
		
		_geometry.repaint();
	}
	
	void start() {
		_initAction.setEnabled(false);
		_stepable.start();
	}
	
	void stop() {
		_thread.interrupt();
	}
	
	void pause() {
		
	}
	
	void step() {
		_stepAction.setEnabled(false);
		_stepable.step();
	}

	@Override
	public void stepped(EventObject event) {
		_geometry.setPopulationBestTransform(_function.convert(
				_ga.getStatistics().getBestPhenotype().getGenotype()
			));
		_geometry.setAlltimeBestTransform(_function.convert(
				_ga.getBestPhenotype().getGenotype()
			));
		
		_stepAction.setEnabled(true);
		
		SwingUtilities.invokeLater(new Runnable() {
			@Override public void run() {
				_geometry.repaint();
			}
		});
	}

	@Override
	public void finished(EventObject event) {	
	}
	
}

class InitAction extends AbstractAction {
	private static final long serialVersionUID = 1L;

	private final GeometryController _controller;
	
	public InitAction(final GeometryController controller) {
		super("Init");
		_controller = controller;
	}
	
	@Override
	public void actionPerformed(final ActionEvent e) {
		_controller.init();
	}
	
}

class StartAction extends AbstractAction {
	private static final long serialVersionUID = 1L;

	private final GeometryController _controller;
	
	public StartAction(final GeometryController controller) {
		super("Start");
		_controller = controller;
	}
	
	@Override
	public void actionPerformed(final ActionEvent e) {
		_controller.start();
	}
	
}

class StopAction extends AbstractAction {
	private static final long serialVersionUID = 1L;

	private final GeometryController _controller;
	
	public StopAction(final GeometryController controller) {
		super("Stop");
		_controller = controller;
	}
	
	@Override
	public void actionPerformed(final ActionEvent e) {
		_controller.stop();
	}
	
}

class PauseAction extends AbstractAction {
	private static final long serialVersionUID = 1L;

	private final GeometryController _controller;
	
	public PauseAction(final GeometryController controller) {
		super("Pause");
		_controller = controller;
	}
	
	@Override
	public void actionPerformed(final ActionEvent e) {
		_controller.pause();
	}
	
}

class StepAction extends AbstractAction {
	private static final long serialVersionUID = 1L;

	private final GeometryController _controller;
	
	public StepAction(final GeometryController controller) {
		super("Step");
		_controller = controller;
	}
	
	@Override
	public void actionPerformed(final ActionEvent e) {
		_controller.step();
	}
	
}


/**
 * The panel which draws the polygons.
 * 
 * @author <a href="mailto:franz.wilhelmstoetter@gmx.at">Franz Wilhelmstötter</a>
 * @version $Id: Geometry.java,v 1.1 2009-03-09 18:48:21 fwilhelm Exp $
 */
class DrawPanel extends JPanel {
	private static final long serialVersionUID = 1L;
	
	private Point2D[] _sourcePolygon;
	private Point2D[] _targetPolygon;
	
	private final AtomicReference<AffineTransform> _populationBestTransform = 
		new AtomicReference<AffineTransform>();
	
	private final AtomicReference<AffineTransform> _alltimeBestTransform =
		new AtomicReference<AffineTransform>();
	
	public DrawPanel() {	
		addComponentListener(new ComponentAdapter() {
			@Override public void componentResized(ComponentEvent e) {
				DrawPanel.this.repaint();
			}
		});
	}
	
	@Override
	public void paintComponent(final Graphics graphics) {
		super.paintComponent(graphics);
		
		final Graphics2D g2d = (Graphics2D)graphics;
		g2d.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_ON);
		
		
		paintCoordinates(g2d);
		
		final AffineTransform transform = AffineTransform.getScaleInstance(1.0, 1.0);
		
		if (_sourcePolygon != null) {
			paint(g2d, _sourcePolygon, Color.BLACK, transform);
		}
		
		if (_targetPolygon != null) {
			paint(g2d, _targetPolygon, Color.GREEN, transform);
			
			AffineTransform at = _populationBestTransform.get();
			if (at != null) {
				paint(g2d, _targetPolygon, Color.BLUE, at);
			} else {
				paint(g2d, _targetPolygon, Color.BLUE, transform);
			}
			
			at = _alltimeBestTransform.get();
			if (at != null) {
				paint(g2d, _targetPolygon, Color.RED, at);
			} else {
				paint(g2d, _targetPolygon, Color.RED, transform);
			}
		}
	}
	
	private void paintCoordinates(final Graphics2D graphics) {
		final Dimension size = getSize();
		final int ox = size.width/2;
		final int oy = size.height/2;
		
		graphics.drawLine(ox, 0, ox, size.height);
		graphics.drawLine(0, oy, size.width, oy);
	}
	
	
	private void paint(
		final Graphics2D graphics, 
		final Point2D[] polygon,
		final Color color,
		final AffineTransform transform
	) {
		final Color oldColor = graphics.getColor();
		graphics.setColor(color);
		
		final Dimension size = getSize();
		final int ox = size.width/2;
		final int oy = size.height/2;
		
		for (int i = 0; i < polygon.length; ++i) {
			final Point2D p1 = transform.transform(polygon[i], null);
			final Point2D p2 = transform.transform(polygon[(i + 1)%polygon.length], null);
			
			graphics.drawLine(
				(int)p1.getX() + ox, -(int)p1.getY() + oy, 
				(int)p2.getX() + ox, -(int)p2.getY() + oy
			);
		}
		
		graphics.setColor(oldColor);
	}
	
	public void setSourcePolygon(final Point2D[] polygon) {
		_sourcePolygon = polygon;
	}
	
	public void setTargetPolygon(final Point2D[] polygon) {
		_targetPolygon = polygon;
	}
	
	public void setPopulationBestTransform(final AffineTransform transform) {
		_populationBestTransform.set(transform);
	}
	
	public void setAlltimeBestTransform(final AffineTransform transform) {
		_alltimeBestTransform.set(transform);
	}
	
}


/**
 * @author <a href="mailto:franz.wilhelmstoetter@gmx.at">Franz Wilhelmstötter</a>
 * @version $Id: Geometry.java,v 1.1 2009-03-09 18:48:21 fwilhelm Exp $
 */
class Stepable implements Runnable {
	private final Lock _lock = new ReentrantLock();
	private final Condition _run = _lock.newCondition();

	private final List<StepListener> _listeners = new CopyOnWriteArrayList<StepListener>();
	
	private long _steps = 0;
	private final Runnable _stepTask;

	public Stepable(final Runnable stepTask) {
		_stepTask = stepTask;
	}

	public void start() {
		_lock.lock();
		try {
			_steps = Long.MAX_VALUE;
			_run.signalAll();
		} finally {
			_lock.unlock();
		}
	}

	public void stop() {
		_lock.lock();
		try {
			_steps = 0;
			_run.signalAll();
		} finally {
			_lock.unlock();
		}
	}

	public void step(int steps) {
		_lock.lock();
		try {
			_steps += steps;
			_run.signalAll();
		} finally {
			_lock.unlock();
		}
	}

	public void step() {
		step(1);
	}

	private void waiting() throws InterruptedException {
		_lock.lock();
		try {
			while (_steps <= 0) {
				_run.await();
			}
		} finally {
			_lock.unlock();
		}
	}

	private boolean execute() {
		_lock.lock();
		try {
			return _steps-- > 0;
		} finally {
			_lock.unlock();
		}
	}

	@Override
	public void run() {
		try {
			while (!Thread.currentThread().isInterrupted()) {
				waiting();
				
				while (execute()) {
					_stepTask.run();
					
					final EventObject event = new EventObject(this);
					for (StepListener listener : _listeners) {
						listener.stepped(event);
					}
				}
			}
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		} finally {
			final EventObject event = new EventObject(this);
			for (StepListener listener : _listeners) {
				listener.finished(event);
			}
		}
	}
	
	public void addStepListener(final StepListener listener) {
		_listeners.add(listener);
	}
	
	public void removeStepListener(final StepListener listener) {
		_listeners.remove(listener);
	}

}

interface StepListener extends EventListener {
	
	public void stepped(EventObject event);
	
	public void finished(EventObject event);
	
}



/**
 * @author <a href="mailto:franz.wilhelmstoetter@gmx.at">Franz Wilhelmstötter</a>
 * @version $Id: Geometry.java,v 1.1 2009-03-09 18:48:21 fwilhelm Exp $
 */
class GA {
	
	static class Function 
		implements FitnessFunction<DoubleGene, Float64>, 
					Converter<Genotype<DoubleGene>, AffineTransform> 
	{
		private static final long serialVersionUID = 1L;
	
		private final Point2D[] _source;
		private final Point2D[] _target;
	
		public Function() {
			this(null, null);
		}
		
		public Function(final Point2D[] source, final Point2D[] target) {
			_source = source != null ? source.clone() : source;
			_target = target != null ? target.clone() : target;
		}
	
		@Override
		public Float64 evaluate(final Genotype<DoubleGene> genotype) {
			final AffineTransform transform = convert(genotype);
	
			double error = 0;
			Point2D point = new Point2D.Double();
			for (int i = 0; i < _source.length; ++i) {
				point = transform.transform(_target[i], point);
	
				error += _source[i].distance(point);
			}
	
			return Float64.valueOf(100000 - error);
		}
	
		@Override
		public AffineTransform convert(final Genotype<DoubleGene> genotype) {
			final double theta = genotype.getChromosome(0).getGene().doubleValue();
			final double tx = genotype.getChromosome(1).getGene(0).doubleValue();
			final double ty = genotype.getChromosome(1).getGene(1).doubleValue();
			final double shx = genotype.getChromosome(2).getGene(0).doubleValue();
			final double shy = genotype.getChromosome(2).getGene(1).doubleValue();
	
			final AffineTransform rotate = AffineTransform.getRotateInstance(theta);
			final AffineTransform translate = AffineTransform.getTranslateInstance(tx, ty);
			final AffineTransform shear = AffineTransform.getShearInstance(shx,shy);
	
			final AffineTransform transform = new AffineTransform();
			transform.concatenate(shear);
			transform.concatenate(rotate);
			transform.concatenate(translate);
	
			return transform;
		}
	
	}
	
	
	private static final Point2D[] SOURCE_POLYGON = new Point2D[] {
			new Point2D.Double(-100, -100),
			new Point2D.Double(100, -100),
			new Point2D.Double(100, 100),
			new Point2D.Double(-100, 100)
		};
	
	private GA() {
	}
	
	public static Factory<Genotype<DoubleGene>> getGenotypeFactory() {
		return Genotype.valueOf(
			//Rotation
			new DoubleChromosome(DoubleGene.valueOf(-Math.PI, Math.PI)),
			
			//Translation
			new DoubleChromosome(DoubleGene.valueOf(-300, 300), DoubleGene.valueOf(-300, 300)),
			
			//Shear
			new DoubleChromosome(DoubleGene.valueOf(-0.5, 0.5), DoubleGene.valueOf(-0.5, 0.5))
		);
	}
	
	public static Point2D[] getSourcePolygon() {
		return SOURCE_POLYGON;
	}
	
	public static Point2D[] getTargetPolygon() {
		final Random random = new Random(System.currentTimeMillis());
		final double theta = random.nextDouble()*2*Math.PI - Math.PI;
		final double tx = random.nextInt(600) - 300;
		final double ty = random.nextInt(600) - 300;
		final double shx = random.nextDouble() - 0.5;
		final double shy = random.nextDouble() - 0.5;
		
		final AffineTransform rotate = AffineTransform.getRotateInstance(theta);
		final AffineTransform translate = AffineTransform.getTranslateInstance(tx, ty);
		final AffineTransform shear = AffineTransform.getShearInstance(shx, shy);
		
		final AffineTransform transform = new AffineTransform();
		transform.concatenate(shear);
		transform.concatenate(rotate);
		transform.concatenate(translate);
		
		final Point2D[] target = new Point2D[SOURCE_POLYGON.length];
		try {
			for (int i = 0; i < SOURCE_POLYGON.length; ++i) {
				target[i]  = transform.transform(SOURCE_POLYGON[i], null);
			}
		} catch (Exception ignore) {
		}
		
		return target;
	}

}











